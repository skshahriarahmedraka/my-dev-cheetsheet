# Rust strings 
mainly 2 types:  String, &str

String :  create/modify strings

&str : Read/analyze strings 

&str  is same as &'static str

- str is a dynamic string type , the size of str is not known at compile time , so we need reference for the string  like  &str



###  Box<str> 
owned, non-growable,heap-allocated string slice 

example : 
```
let my_string:String= String::from("raka");

// convert the String into a Box<str>
let my_box_str: Box<str> = my_string.into_boxed_str();

// now you can use `my_box_str` just like a &str, but it's own. 
println!("my box str: {}", my_boxed_str);

```


### Rc<str>
shared,immutable string slice 

```
use std::rc::Rc;

fn main(){
	let some_large_text:&'static str = "sk shahriar ahmed raka";

	// extract a subsection that multiple parts of the program will need to reference 
	let subsection:Rc<str> =Rc::from(&some_large_text[5..10]);

	// simulate multiple owners by cloning the Rc 
	let another_reference = Rc::clone(&subsection);
	let yet_another_reference= Rc::clone(&subsection);

	println!("First reference: {}",subsection);
	println!("First reference: {}",another_reference);
	println!("First reference: {}",yet_another_reference);
}

```

###  Arc<str>
shared,thread-safe,immutable string slice 
```
fn main{
	// create String, which doestn't have 'static lifetime
	let text_string= String::from("sk shahriar ahmed raka");
	let text_slice=&text_string[..];

	// convert it to an Arc<str>
	let shared_text= Arc::from(text_slice);

	let mut handles = vec![];

	for _ in 0..3 {
		let text_ref= Arc::clone(&shared_text);
		let handle = thread::spawn(move || {
				println!("thread is reading: {}",text_ref);
			})
			handles.push(handle);
	}

	for handle in handles {
		handle.join().unwrap();
	}
}
```


-- note: String type is actually a rapper of Vec<u8>



### Cow<'a,str>
-- Copy on write 

this useful when a function sometime modify a string and sometime dont 

```
use std::borrow::Cow;

fn sanitize(input: &str) -> Cow<str> {
	if input.contains("badword") {
		let sanitized: String = input.replace("badword","****");
		return Cow::Own(sanitized) ;
	}
	Cow::Borrowed(input)
}

```


## OsString & OsStr
-- inter operability with OS

```
fn main() -> std::io::Result<()> {
	let paths = fs::read_dir(".")?; 

	for path in paths {
		match path {
			Ok(entry) => {
				let os_string: OsString= entry.file_name();
				match os_string.into_string() {
					Ok(string) => println!("found a file: {}", string),
					Err(os_string) => println!("found a non-UTF-8 filename: {:?} ", os_string),
				}
				Err(_) => println!("Couldn't read the path"),
			}
		}
	}
	Ok(())
}

```

### Path & PathBuf 


```
fn read_file(dir: &Paht,filename: &str) -> std::io::Result<String> {
	let mut full_path= PathBuf::from(dir); 
	full_path.push(filename); 

	let mut file = File::open(full_path)?; 
	let mut content =String::new();
	file.read_to_string(&mut content)?;

	Ok(content)
}
```

fn main() -> std::io::Result<()> {
	let dir = Path::new("./");
	let content = read_file(dir,"example.txt");
	println!("file content: {}", content);

	Ok(())
}


## CStr & CString

```
extern "C" {
	fn getenv(name: *cont std::os::raw::c_char) -> *const std::os::raw::c_char; 
}

use std::ffi::{CStr,CString} ;

fn main() {
	let key = CString::new("PATH").expect("CString::new failed");
	unsafe {
		let val = getenv(key.as_ptr()) ;
		if var.is_null() {
			let c_str = CStr::from_prt(val);
			let str_slice = s_str.to_str().unwrap();
			println!("Found: {}",str_slice);
		}else {
			println!("not found");
		}
	}
}


```

